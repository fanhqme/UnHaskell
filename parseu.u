(import* io)
(import* str)
; SPosition (Int,Int)
(def SPosition ^2)
; SError (String,SPosition)
(def SError ^2)
(let showSPosition (showPair showInt showInt))
(let showPositionedChar (showPair showCharL showSPosition))
(let showListPositionedChar (showList showPositionedChar))
(let tokenToString (\e (e
	(\a a)
	(\a (itoa a))
	(\a (ftoa a))
	(\a "(")
	(\a ")")
	(\a "\\")
	(\a a)
)))
(let tokenToNumber (\e (e
	(\a 0)
	(\a a)
	(\a a)
	(\a 0)
	(\a 0)
	(\a 0)
	(\a 0)
)))
(let showToken (. showString tokenToString))
;(let showToken tokenToString)
(let showPositionedToken (showPair showToken showSPosition))
(let showListPositionedToken (showList showPositionedToken))
(def onSError (feed (\msg pos (run
	(_ (putStr msg))
	(_ (putStr " at "))
	(_ (putStrLn (showSPosition pos "")))
	(exit 1)
))))
(let pass (\e (run
	(tmp (e onSError))
	(@1_2 tmp)
)))
(def annotatePositions (\content
	(zip content (scanl
		(\l0c0 c (l0c0 (\l0 c0
			((= c '\n') (pair (+ 1 l0) 0)
				(pair l0 (+ 1 c0)))
		))) (SPosition 0 0) content)
	)
))
(def dropWhiteSpace (recur (\self (\l (run    ; either SError or ListPositionedChar
	(let waitUntilClose (recur (\self2 (\ar ap (run
		( ((null ar) (@0_2 (SError "unclosed block comment" ap))))
		(let a1 (head ar))
		(let t1 (tail ar))
		( ((null t1) (@0_2 (SError "unclosed block comment" ap))))
		(let a2 (head t1))
		(let t2 (tail t1))
		( ((and (= (fst a1) '|') (= (fst a2) '#')) (self t2)))
		(self2 t1 ap)
	)))))
	(aap ar (l (@1_2 empty)))
	(a ap aap)
	( ((isSpace a) (self ar)))
	( ((= a ';') (self (dropWhile (. (/= '\n') fst) ar))))
	( ((and (and (= a '#') (not (null ar))) (= (fst (head ar)) '|')) (waitUntilClose (tail ar) ap)))
	(@1_2 l)
)))))
(def isValidCharInt (\x
	(and (>= x 0) (< x 1114112))
))
(def intFromDigits atoi)
(def splitChrSpecial (\ar ap (run
	( ((null ar) (@0_2 (SError "incomplete escape sequence" ap))))
	(let h (head ar))
	(let arr (tail ar))
	(ch pos h)
	( ((= ch 'a') (@1_2 (pair '\a' arr))))
	( ((= ch 'b') (@1_2 (pair '\b' arr))))
	( ((= ch 'n') (@1_2 (pair '\n' arr))))
	( ((= ch 'r') (@1_2 (pair '\r' arr))))
	( ((= ch 'v') (@1_2 (pair '\v' arr))))
	( ((= ch 'f') (@1_2 (pair '\f' arr))))
	( ((= ch 't') (@1_2 (pair '\t' arr))))
	( ((= ch '\\') (@1_2 (pair '\\' arr))))
	( ((= ch '\'') (@1_2 (pair '\'' arr))))
	( ((= ch '\"') (@1_2 (pair '\"' arr))))
	( ((= ch 'x') 
		(run
			(let tmp (span (\p (isDigit (fst p))) arr))
			(npart arrr tmp)
			( ((null npart) (@0_2 (SError "\\x must be followed by digits" ap))))
			(let c_int (intFromDigits (map fst npart)))
			( ((isValidCharInt c_int) (@1_2 (pair c_int arrr))))
			(@0_2 (SError "\\x value not in range" ap))
		)
	))
	(@1_2 (pair ch arr))
)))
(def splitStrLiteral (recur (\self (\ar ap (run
	( ((null ar) (@0_2 (SError "unmatched \"" ap))))
	(let h (head ar))
	(let arr (tail ar))
	(ch pos h)
	( ((= ch '"') (@1_2 (pair (pair (@6_7 empty) pos) arr))))
	( ((= ch '\\') 
		(run
			(tmp (splitChrSpecial arr pos onSError))
			(c arrr tmp)
			(tmp2 (self arrr ap onSError))
			(tmp3 arrrr tmp2)
			(tmp4 _ tmp3)
			(let sr (tokenToString tmp4))
			(@1_2 (pair (pair (@6_7 (cons c sr)) ap) arrrr))
		)
	))
	(run
		(tmp (self arr ap onSError))
		(tmp2 arrr tmp)
		(tmp3 _ tmp2)
		(let sr (tokenToString tmp3))
		(@1_2 (pair (pair (@6_7 (cons ch sr)) ap) arrr))
	)
)))))
(def splitCharLiteral (recur (\self (\ar ap (run
	( ((null ar) (@0_2 (SError "unmatched \'" ap))))
	(let h (head ar))
	(let arr (tail ar))
	(ch pos h)
	( ((and (= ch '\'') (null arr)) (@0_2 (SError "empty ''" ap))))
	( ((= ch '\\') 
		(run
			(tmp (splitChrSpecial arr ap onSError))
			(c arrr tmp)
			( ((null arrr) (@0_2 (SError "unmatched \'" ap))))
			(let h2 (head arrr))
			(let arrrr (tail arrr))
			(ch2 pos2 h2)
			( ((= ch2 '\'') (@1_2 (pair (pair (@1_7 (tokenToNumber c)) ap) arrrr))))
			(@0_2 (SError "unmatched \'" ap))
		)
	))
	( ((null arr) (@0_2 (SError "unmatched \'" ap))))
	(let h2 (head arr))
	(let arrr (tail arr))
	(ch2 pos2 h2)
	( ((= ch2 '\'') (@1_2 (pair (pair (@1_7 ch) ap) arrr))))
	(@0_2 (SError "unmatched \'" ap))
)))))
(def isStopChar (\c (or (isSpace c) (elem c (list '\\' ';' '(' ')')))))
(def splitFirstString (\l (run
	(let aap (head l))
	(let ar (tail l))
	(a ap aap)
	( ((= a '(') (@1_2 (pair (pair (@3_7 empty) ap) ar))))
	( ((= a ')') (@1_2 (pair (pair (@4_7 empty) ap) ar))))
	( ((= a '\\') (@1_2 (pair (pair (@5_7 empty) ap) ar))))
	( ((= a '"') (splitStrLiteral ar ap)))
	( ((= a '\'') (splitCharLiteral ar ap)))
	(let tmp (span (\p (not (isStopChar (fst p)))) l))
	(al arr tmp)
	(@1_2 (pair (pair (@0_7 (map fst al)) ap) arr))
)))
(def groupStrings (recur (\self (\a (run
	( ((null a) (@1_2 empty)))
	(tmp (splitFirstString a onSError))
	(f r tmp)
	(rr (dropWhiteSpace r onSError))
	(remain (self rr onSError))
	(@1_2 (cons f remain))
)))))

(run
	;(let c ((isStopChar '\\') 65 66))
	;(_ (putChar c))
	(let inp "(def a \"haha\")\n (+ a b)")
	(_ (putStrLn inp))
	(let annotated (annotatePositions inp))
	;(_ (putStrLn (showListPositionedChar annotated "")))

	(chopped (dropWhiteSpace annotated onSError))
	;(_ (putStrLn (showListPositionedChar chopped "")))
	;(let grouped (cons (pair (@0_7 "abc") (SPosition 0 0)) empty))
	(grouped (groupStrings chopped onSError))
	(_ (putStrLn (showListPositionedToken grouped "")))
	;(let c ((isSpace 'a') 65 66))
	;(_ (putChar c))
	;(_ (putStrLn (showToken (@0_7 "abc") "")))
	;(_ (putStrLn (showPositionedToken (pair (@0_7 "abc") (SPosition 0 0)) "")))
	(exit 0)
)
