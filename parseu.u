(import* io)
(import* str)
; SPosition (Int,Int)
(def SPosition ^2)
(def SFail (\msg pos (\on_fail on_succ (on_fail msg pos))))
(def SSucc (\a (\on_fail on_succ (on_succ a))))
(let showSPosition (showPair showInt showInt))
(let showPositionedChar (showPair showCharL showSPosition))
(let showListPositionedChar (showList showPositionedChar))

(def STAtom (\a f1 f2 f3 f4 f5 f6 f7 (f1 a)))
(def STInt (\a f1 f2 f3 f4 f5 f6 f7 (f2 a)))
(def STDouble (\a f1 f2 f3 f4 f5 f6 f7 (f3 a)))
(def STLeftPar (\f1 f2 f3 f4 f5 f6 f7 f4))
(def STRightPar (\f1 f2 f3 f4 f5 f6 f7 f5))
(def STLambda (\f1 f2 f3 f4 f5 f6 f7 f6))
(def STStr (\a f1 f2 f3 f4 f5 f6 f7 (f7 a)))
(def showSTToken (\t (t
	(\a (. (showString "(STAtom ") (. (showStringL a) (showString ")"))))
	(\a (. (showString "(STInt ") (. (showInt a) (showString ")"))))
	(\a (. (showString "(STDouble ") (. (showFloat a) (showString ")"))))
	(showString "STLeftPar")
	(showString "STRightPar")
	(showString "STLambda")
	(\a (. (showString "(STStr ") (. (showStringL a) (showString ")"))))
)))
(let showPositionedSTToken (showPair showSTToken showSPosition))
(let showListPositionedSTToken (showList showPositionedSTToken))

(def annotatePositions (\content
	(zip content (scanl
		(\l0c0 c (l0c0 (\l0 c0
			((= c '\n') (pair (+ 1 l0) 0)
				(pair l0 (+ 1 c0)))
		))) (SPosition 0 0) content)
	)
))
(def dropWhiteSpace (recur (\self (\l (run    ; SMayFail [(Char,SPosition)]
	(aap ar (l (SSucc empty)))
	(a ap aap)
	( ((isSpace a) (self ar)))
	( ((= a ';') (self (dropWhile (. (/= '\n') fst) ar))))
	(let waitUntilClose (recur (\f (\ar ap (run
		(har arr (ar (SFail "unclosed block comment" ap)))
		(harr arrr (arr (SFail "unclosed block comment" ap)))
		( ((and (= (fst har) '|') (= (fst harr) '#')) (self arrr)))
		(f arr ap)
	)))))
	( (\c ((/= a '#') c (ar c (\har arr ((= (fst har) '|') (waitUntilClose arr ap) c))))))
	(SSucc l)
)))))

(let isValidCharInt (\a (and (>= a 0) (< a 256))))

;splitChrSpecial :: [(Char,SPosition)] -> SPosition -> SMayFail (Char,[(Char,SPosition)])
(def splitChrSpecial (\ar ap (run
	(har arr (ar (SFail "incomplete escape sequence" ap)))
	( ((= (fst har) 'a') (SSucc (pair '\a' arr))))
	( ((= (fst har) 'b') (SSucc (pair '\b' arr))))
	( ((= (fst har) 'n') (SSucc (pair '\n' arr))))
	( ((= (fst har) 'r') (SSucc (pair '\r' arr))))
	( ((= (fst har) 'v') (SSucc (pair '\v' arr))))
	( ((= (fst har) 'f') (SSucc (pair '\f' arr))))
	( ((= (fst har) 't') (SSucc (pair '\t' arr))))
	( ((= (fst har) '\\') (SSucc (pair '\\' arr))))
	( ((= (fst har) '\'') (SSucc (pair '\'' arr))))
	( ((= (fst har) '\"') (SSucc (pair '\"' arr))))
	( ((= (fst har) 'x') (run
		(npart arrr (span (. isDigit fst) arr))
		(_ _ (npart (SFail "\\x must be followed by digits" ap)))
		(let c_int (intFromDigits (map fst npart)))
		( (isValidCharInt c_int (SSucc (pair c_int arrr))))
		(SFail "\\x value not in range" ap)
	)))
	(SSucc (pair (fst har) arr))
)))
; splitStrLiteral :: [(Char,SPosition)] -> SPosition -> SMayFail ((SToken,SPosition),[(Char,SPosition)])
(def splitStrLiteral (\ar ap (run
	; splitStrLiteralS :: [(Char,SPosition)] -> SMayFail ([Char],[(Char,SPosition)])
	(let splitStrLiteralS (recur (\self (\ar ap (run
		(har arr (ar (SFail "unmatched \"" ap)))
		( ((= (fst har) '"') (SSucc (pair "" arr))))
		( ((= (fst har) '\\') (run
			(c arrr (. (splitChrSpecial arr (snd har) SFail) feed))
			(sr arrrr (. (self arrr ap SFail) feed))
			(SSucc (pair (cons c sr) arrrr))
		)))
		(sr arrr (. (self arr ap SFail) feed))
		(SSucc (pair (cons (fst har) sr) arrr))
	)))))
	(ps (splitStrLiteralS ar ap SFail))
	(s r ps)
	(SSucc (pair (pair (STStr s) ap) r))
)))
; splitCharLiteral :: [(Char,SPosition)] -> SPosition -> SMayFail ((SToken,SPosition),[(Char,SPosition)])
(def splitCharLiteral (recur (\self (\ar ap (run
	(har arr (ar (SFail "unmatched \'" ap)))
	( ((= (fst har) '\'') (SFail "empty ''" ap)))
	(let on_error (SFail "unmatched \'" ap))
	( ((= (fst har) '\\') (run
		(c arrr (. (splitChrSpecial arr ap SFail) feed))
		(harrr arrrr (arrr on_error))
		( ((= (fst harrr) '\'') (SSucc (pair (pair (STInt c) ap) arrrr))))
		on_error
	)))
	(harr arrr (arr on_error))
	( ((= (fst harr) '\'') (SSucc (pair (pair (STInt (fst har)) ap) arr))))
	on_error
)))))
(def isStopChar (\c (or (isSpace c) (any (= c) "()\\;"))))

; splitNumLiteral :: [(Char,SPosition)] -> SMayFail ((SToken,SPosition),[(Char,SPosition)]) 
(def splitNumLiteral (\a (run
	(let ap (a (SPosition 0 0) (\h _ (snd h))))
	(sign a1 (run
		(ha ar (a (pair 1 a)))
		( ((= (fst ha) '+') (pair 1 ar)))
		( ((= (fst ha) '-') (pair -1 ar)))
		(pair 1 a)
	))
	(before_dot after_dot1 (span (. isDigit fst) a1))
	(let intret (SSucc (pair (pair (STInt (* sign (intFromDigits (map fst before_dot)))) ap) after_dot1)))
	( (\c (after_dot1 intret (\h r ((isStopChar (fst h)) intret c)))))
	(let after_dot (after_dot1 after_dot1 (\h r ((= (fst h) '.') r after_dot1))))
	(before_e after_e1 (span (. isDigit fst) after_dot))
	(has_e after_e (run
		(let other (pair False after_e1))
		(h r (after_e1 other))
		( ((= (fst h) 'e') (pair True r)))
		( ((= (fst h) 'E') (pair True r)))
		other
	))
	(neg_e after_es (run
		(let other (pair False after_e))
		( ((not has_e) other))
		(h r (after_e other))
		( ((= (fst h) '+') (pair False r)))
		( ((= (fst h) '-') (pair True r)))
		other
	))
	(before_end remain (span (. isDigit fst) after_es))
	( ((and has_e (null before_end)) (SFail "invalid float literal " ap)))
	(let int_part (intFromDigits (map fst before_dot)))
	(let mentisa_part (sum (zipWith * (map (. intFromDigit fst) before_e) (iterate (* 0.1) 0.1))))
	(let expint (before_end 0 (\_ _ (intFromDigits (map fst before_end)))))
	(let expbase (neg_e 0.1 10))
	(let e_part (iterateN expint (* expbase) 1))
	(SSucc (pair (pair (STDouble (* sign (* e_part (+ int_part mentisa_part)))) ap) remain))
)))

; splitFirstString :: [(Char,SPosition)] -> SMayFail ((SToken,SPosition),[(Char,SPosition)])
(def splitFirstString (\la (run
	(aap ar (la 0))
	(a ap aap)
	( ((= a '(') (SSucc (pair (pair STLeftPar ap) ar))))
	( ((= a ')') (SSucc (pair (pair STRightPar ap) ar))))
	( ((= a '\\') (SSucc (pair (pair STLambda ap) ar))))
	( ((= a '"') (splitStrLiteral ar ap)))
	( ((= a '\'') (splitCharLiteral ar ap)))
	( (((isDigit a) True ((any (= a) "+-.") (ar False (\h r (isDigit (fst h)))) False)) (splitNumLiteral la)))
	( ((isDigit a) (SFail "invalid number literal" ap)))
	(al arr (span (. not (. isStopChar fst)) la))
	(SSucc (pair (pair (STAtom (map fst al)) ap) arr))
)))

; groupStrings :: [(Char,SPosition)] -> SMayFail [(SToken,SPosition)] 
(def groupStrings (recur (\self (\x (run
	(dropped (dropWhiteSpace x SFail))
	(let groupStrings' (\a (run
		(_ _ (a (SSucc empty)))
		(f r (. (splitFirstString a SFail) feed))
		(remain (self r SFail))
		(SSucc (cons f remain))
	)))
	(groupStrings' dropped)
)))))

(run
	(let inp " ;haha\n #|lala|# #| papa|# ; pia\n(def a 1)\n(+ a 2)")
	;(let inp "")
	;(let inp " a\\nbc\" a")
	;(let inp "a' bc")
	;(let inp "")
	(let annotated (annotatePositions inp))
	;(_ (putStrLn (showListPositionedChar annotated "")))
	(let onSError (\msg pos (run
		(_ (putStr (++ "parser error: " (++ msg " at "))))
		(_ (putStrLn (showSPosition pos "")))
		(exit 1)
	)))
	; (chopped (dropWhiteSpace annotated onSError))
	; (_ (putStrLn (showListPositionedChar chopped "")))
	; (_ (putStrLn (map fst chopped)))
	;(splitted (splitChrSpecial annotated (SPosition 0 0) onSError))
	;(c r splitted)
	;(_ (putStrLn (itoa c)))
	;(pst r (. (splitStrLiteral annotated (SPosition 0 0) onSError) feed))
	;(pst r (. (splitCharLiteral annotated (SPosition 0 0) onSError) feed))
	;(pst r (. (splitNumLiteral annotated onSError) feed))
	;(pst r (. (splitFirstString annotated onSError) feed))
	;(_ (putStrLn (showSTToken (fst pst) "")))
	;(_ (putStrLn (showSPosition (snd pst) "")))
	;(_ (putStrLn (showListPositionedChar r "")))
	(sts (groupStrings annotated onSError))
	(_ (putStrLn (showListPositionedSTToken sts "")))
	(exit 0)
)
